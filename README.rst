BOHR
----------------------------------
Big Old Heuristic Repository



.. contents:: **Contents**
  :backlinks: none

Getting started with BOHR
===========================================

Python >= 3.8 is required, preferably use virtual environment.

#. Run ``git clone https://github.com/giganticode/bohr && cd bohr``
#. Install BOHR framework library: ``chmod +x bin/setup-bohr.sh && bin/setup-bohr.sh``. This will install `bohr-framework <https://github.com/giganticode/bohr-framework>`, dependencies and tools to run heursistics.

Downloading datasets and models
===============================

#. Run ``bohr repro``

Bohr extensively uses `DVC (Data Version Control) <https://dvc.org/>`_ to ensure of the datasets and models.

Contributing to heuristics repository:
=======================================


1. Heuristics:
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Heuristics can be found in ``.py`` files in the ``bohr/heuristics`` directory, and are marked with @Heuristic decorator. Example:

.. code-block:: python
 
    @Heuristic(Commit)
    def bugless_if_many_files_changes(commit: Commit) -> Optional[Labels]:
        if len(commit.files) > 6:
            return CommitLabel.NonBugFix
        else:
            return None
            
Important things to note:

#. Any function becomes a heuristic once it is marked with ``@Heuristic`` decorator
#. Artifact type is passed to heuristic decorator as a parameter; method accepts an object of artifact type
#. Method name can be arbitrary as long it is unique and descriptive
#. Method should return ``label`` if a datapoint should be labeled with ``label``, ``None`` if the labeling function should abstain on the datapoint

Please refer to the `documentation <https://giganticode.github.io/bohr/Heuristics.html>`_ for more information on heuristics and special heuristic types.        

2. New tasks:
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Tasks are defined in the `bohr.json` file. Below you can see an example of "bugginess" task.

.. code-block:: json

   "bugginess": {
      "top_artifact": "bohr.artifacts.commit.Commit",
      "label_categories": [
        "CommitLabel.NonBugFix",
        "CommitLabel.BugFix"
      ],
      "test_datasets": [
        "datasets.1151-commits",
        "datasets.berger",
        "datasets.herzig"
      ],
      "train_datasets": [
        "datasets.bugginess-train"
      ],
      "label_column_name": "bug"
    }



The name of the task is the key in the dictionary. The value is an object with the following fields:

#. **Top artifact** - the artifact to be catigorized. In the case of "bugginess" task, commits are classified, therefore the top artifact is ``bohr.artifacts.commit.Commit``;
#. **Label categories** - categories artifact to be classified as, for "bugginess" taks these are *CommitLabel.BugFix* and *CommitLabel.NonBugFix*. Values has to be taken from the ``labels.py`` file. See section `3. Contributing to the label hierarchy:`_ on more information about labels in bohr and how to extend the label hierarchy.
#. **Training sets** - datasets used to train a label model;
#. **Test sets** - datasets to calculate metrics on.

3. Contributing to the label hierarchy:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Artifacts can be labeled with labeled pre-defined in BOHR. Labels are organized in an hierarchy, the are more general labels e.g. ``Commit.BugFix``, there are more specific ones, e.g. ``Commit.MinorBugFix``. There is a binary relation IS-A defined on the set of label which defines a partial order, e.g. ``IS-A(Commit.MinorBugFix, Commit.BugFix)``


Labels are defined in text files under ``bohr/labels``. Each row has a format: <parent>: <list of children>

After the chnages done to the text file with labels, the object hierarchy can be generated by running ``bohr parse-labels``

See this pill request as an example of adding labels to the hieararcy: link to PR

Note that the object hierarhcy of labels is regenerated and push to the repository automatically, once the pull request is recieved: link to commit

4. Contributing a dataset
~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you want to contribute a dataset of artifacts that do not yet exist in bohr, you first need to create an artifact definition. If aritifact type is not yet define proceed with Section 1. Contributing an artifact definition Otherwise you can skip this section. But Make sure that there is a needed DatasetMapper. Dataset mapper define how each datapoint of a dataset is mapped onto an artifact object. If the needed mapper exists, you can skip to Chapter 6 Contributing a dataset, otherwise proceed to chapter 5 Contributing an artifact mapper.

1. Contributing an artifact definition:
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^





2. Contributuing an artifact mapper:
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



3. Contributing a dataset:
^^^^^^^^^^^^^^^^^^^^^^^^^^^



Defining new heuristic type:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Contribute to the framework:
=============================

To contribute to the framework, take a look at the bohr-framework_ repo

.. _bohr-framework: https://github.com/giganticode/bohr-framework


Publications
===========================================


